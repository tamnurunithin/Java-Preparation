âœ…Bubble Sort in Java
Bubble Sort is a simple comparison-based sorting algorithm. It repeatedly compares adjacent elements and swaps them if they are in the wrong order. After each full pass, the largest element "bubbles up" to its correct position at the end.
ðŸ§ Example:
public class BubbleSortExample {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        boolean swapped;
        // Outer loop for passes
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            // Inner loop for comparisons
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Swap elements
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            // If no swap happened 
            â†’ array already sorted
            if (!swapped) break;
        }
    }
    public static void main(String[] args) {
        int[] arr = {5, 3, 8, 4, 2};
        bubbleSort(arr);

        System.out.print("Sorted Array: ");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
Output:
Sorted Array: 2 3 4 5 8

âš¡Time Complexity:
Best Case: O(n)
If the array is already sorted, only one pass is needed (due to the swapped flag optimization).
Worst Case: O(n^2)
If the array is in reverse order, every element needs to be swapped in each pass.
Average Case: O(n^2)
In general, comparisons and swaps are quadratic.

âš¡Space Complexity:
Space Complexity: O(1)
Bubble Sort is an in-place sorting algorithm, meaning it doesnâ€™t need extra memory except a few variables.

ðŸ“ŒWhen do we use O(n), O(1), O(log n)?
O(n):
Happens in Bubble Sort best case (already sorted array). Only one pass through the array is required.
O(1):
Refers to constant space complexity. Bubble Sort does not use extra arrays; it only uses a few variables for swapping.
O(log n):
Bubble Sort never achieves O(log n) because it is not a divide-and-conquer algorithm.
Algorithms like Binary Search or Merge Sort recursion depth achieve O(log n).